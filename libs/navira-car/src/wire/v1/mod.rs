//! CAR v1 related types and utilities
//!
//! This module contains types and utilities related to the CAR v1 format.
//! If you are looking for the main CAR reader/writer, you probably want to use the
//! [CarReader](crate::CarReader) types in the parent module instead, which can handle both CAR v1
//! and v2 formats transparently.
//!
//! However, if you only need to work with CAR v1 headers or sections, you can use the types in this module directly.

pub use data::{Block, LocatableSection, Section, SectionFormatError, SectionLocation};
pub use header::CarHeader;
pub use read::{CarReader, CarReaderError};
pub use write::{CarWriter, CarWriterError};

mod data;
mod header;
mod read;
mod write;

#[cfg(test)]
mod tests {
    use super::{CarReader, CarReaderError};
    use crate::wire::cid::RawCid;

    const CAR_V1: [u8; 715] = [
        // Offset 0x00000000 to 0x000002CA
        0x63, 0xA2, 0x65, 0x72, 0x6F, 0x6F, 0x74, 0x73, 0x82, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01,
        0x71, 0x12, 0x20, 0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F,
        0xA8, 0x30, 0x28, 0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D,
        0xBC, 0x20, 0x0F, 0xAB, 0x8B, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01, 0x71, 0x12, 0x20, 0x69,
        0xEA, 0x07, 0x40, 0xF9, 0x80, 0x7A, 0x28, 0xF4, 0xD9, 0x32, 0xC6, 0x2E, 0x7C, 0x1C, 0x83,
        0xBE, 0x05, 0x5E, 0x55, 0x07, 0x2C, 0x90, 0x26, 0x6A, 0xB3, 0xE7, 0x9D, 0xF6, 0x3A, 0x36,
        0x5B, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x01, 0x5B, 0x01, 0x71, 0x12, 0x20,
        0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F, 0xA8, 0x30, 0x28,
        0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D, 0xBC, 0x20, 0x0F,
        0xAB, 0x8B, 0xA2, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x2A, 0x58, 0x23, 0x00, 0x12, 0x20,
        0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 0xCB, 0x1F,
        0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2, 0x7F,
        0xD3, 0xDE, 0x64, 0x6E, 0x61, 0x6D, 0x65, 0x64, 0x62, 0x6C, 0x69, 0x70, 0x83, 0x01, 0x12,
        0x20, 0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 0xCB,
        0x1F, 0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2,
        0x7F, 0xD3, 0xDE, 0x12, 0x2E, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0xB6, 0xFB, 0xD6, 0x75,
        0xF9, 0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 0xFD, 0xC8, 0x31, 0x50, 0xFE, 0xDC, 0x48,
        0x59, 0x7E, 0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 0x44, 0xA2, 0x74, 0x51, 0x12, 0x04,
        0x62, 0x65, 0x61, 0x72, 0x18, 0x04, 0x12, 0x2F, 0x0A, 0x22, 0x12, 0x20, 0x79, 0xA9, 0x82,
        0xDE, 0x3C, 0x99, 0x07, 0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 0x1D, 0x0F, 0xB1, 0xED, 0x8F,
        0x45, 0xF8, 0xEF, 0x02, 0x87, 0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 0xBD, 0x53, 0x0A, 0x12,
        0x06, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x18, 0x95, 0x01, 0x28, 0x01, 0x55, 0x12, 0x20,
        0xB6, 0xFB, 0xD6, 0x75, 0xF9, 0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 0xFD, 0xC8, 0x31,
        0x50, 0xFE, 0xDC, 0x48, 0x59, 0x7E, 0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 0x44, 0xA2,
        0x74, 0x51, 0x63, 0x63, 0x63, 0x63, 0x80, 0x01, 0x12, 0x20, 0x79, 0xA9, 0x82, 0xDE, 0x3C,
        0x99, 0x07, 0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 0x1D, 0x0F, 0xB1, 0xED, 0x8F, 0x45, 0xF8,
        0xEF, 0x02, 0x87, 0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 0xBD, 0x53, 0x0A, 0x12, 0x2D, 0x0A,
        0x24, 0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 0x86, 0x74, 0xB4, 0x01, 0xB4,
        0x2F, 0x35, 0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 0xBF, 0xFE, 0x65, 0x8D,
        0xA1, 0x57, 0x7E, 0x3E, 0x64, 0x68, 0x77, 0x12, 0x03, 0x64, 0x6F, 0x67, 0x18, 0x04, 0x12,
        0x2D, 0x0A, 0x22, 0x12, 0x20, 0xE7, 0xDC, 0x48, 0x6E, 0x97, 0xE6, 0xEB, 0xE5, 0xCD, 0xAB,
        0xAB, 0x3E, 0x39, 0x2B, 0xDA, 0xD1, 0x28, 0xB6, 0xE0, 0x9A, 0xCC, 0x94, 0xBB, 0x4E, 0x2A,
        0xA2, 0xAF, 0x7B, 0x98, 0x6D, 0x24, 0xD0, 0x12, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0x18,
        0x33, 0x28, 0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 0x86, 0x74, 0xB4, 0x01,
        0xB4, 0x2F, 0x35, 0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 0xBF, 0xFE, 0x65,
        0x8D, 0xA1, 0x57, 0x7E, 0x3E, 0x64, 0x68, 0x77, 0x62, 0x62, 0x62, 0x62, 0x51, 0x12, 0x20,
        0xE7, 0xDC, 0x48, 0x6E, 0x97, 0xE6, 0xEB, 0xE5, 0xCD, 0xAB, 0xAB, 0x3E, 0x39, 0x2B, 0xDA,
        0xD1, 0x28, 0xB6, 0xE0, 0x9A, 0xCC, 0x94, 0xBB, 0x4E, 0x2A, 0xA2, 0xAF, 0x7B, 0x98, 0x6D,
        0x24, 0xD0, 0x12, 0x2D, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0x61, 0xBE, 0x55, 0xA8, 0xE2,
        0xF6, 0xB4, 0xE1, 0x72, 0x33, 0x8B, 0xDD, 0xF1, 0x84, 0xD6, 0xDB, 0xEE, 0x29, 0xC9, 0x88,
        0x53, 0xE0, 0xA0, 0x48, 0x5E, 0xCE, 0xE7, 0xF2, 0x7B, 0x9A, 0xF0, 0xB4, 0x12, 0x03, 0x63,
        0x61, 0x74, 0x18, 0x04, 0x28, 0x01, 0x55, 0x12, 0x20, 0x61, 0xBE, 0x55, 0xA8, 0xE2, 0xF6,
        0xB4, 0xE1, 0x72, 0x33, 0x8B, 0xDD, 0xF1, 0x84, 0xD6, 0xDB, 0xEE, 0x29, 0xC9, 0x88, 0x53,
        0xE0, 0xA0, 0x48, 0x5E, 0xCE, 0xE7, 0xF2, 0x7B, 0x9A, 0xF0, 0xB4, 0x61, 0x61, 0x61, 0x61,
        0x36, 0x01, 0x71, 0x12, 0x20, 0x69, 0xEA, 0x07, 0x40, 0xF9, 0x80, 0x7A, 0x28, 0xF4, 0xD9,
        0x32, 0xC6, 0x2E, 0x7C, 0x1C, 0x83, 0xBE, 0x05, 0x5E, 0x55, 0x07, 0x2C, 0x90, 0x26, 0x6A,
        0xB3, 0xE7, 0x9D, 0xF6, 0x3A, 0x36, 0x5B, 0xA2, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xF6, 0x64,
        0x6E, 0x61, 0x6D, 0x65, 0x65, 0x6C, 0x69, 0x6D, 0x62, 0x6F,
    ];

    #[test]
    fn test_car_v1_reader_read_header() {
        let mut reader = CarReader::new();
        let chunk_size = 50;

        loop {
            match reader.read_header() {
                Ok(()) => {
                    // Header read successfully
                    break;
                }
                Err(CarReaderError::InsufficientData(read_from, _)) => {
                    // Provide more data
                    let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                    if read_from >= end {
                        panic!("Test data exhausted before header could be read");
                    }
                    reader.receive_data(&CAR_V1[read_from..end], read_from);
                }
                Err(err) => {
                    panic!("Unexpected error while reading header: {:?}", err);
                }
            }
        }

        let header = reader.header().unwrap();
        assert_eq!(header.version(), 1);
        assert_eq!(header.roots().len(), 2);
    }

    #[test]
    fn test_car_v1_reader_count_sections() {
        let mut reader = CarReader::new();
        let chunk_size = 50;
        let mut block_bytes = 0;
        let mut block_count = 0;

        // First, read the header
        loop {
            match reader.read_header() {
                Ok(()) => break,
                Err(CarReaderError::InsufficientData(read_from, _)) => {
                    let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                    if read_from >= end {
                        panic!("Test data exhausted before header could be read");
                    }
                    reader.receive_data(&CAR_V1[read_from..end], read_from);
                }
                Err(err) => {
                    panic!("Unexpected error while reading header: {:?}", err);
                }
            }
        }

        // Seek to the first section - Not needed here

        // Now, read sections
        loop {
            match reader.read_section() {
                Ok(section) => {
                    block_bytes += section.block().data().len();
                    block_count += 1;
                    println!("Read section with CID: {:?}", section.cid());
                }
                Err(CarReaderError::InsufficientData(read_from, _)) => {
                    let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                    if read_from >= end {
                        // No more data to read
                        break;
                    }
                    reader.receive_data(&CAR_V1[read_from..end], read_from);
                }
                Err(err) => {
                    panic!("Unexpected error while reading section: {:?}", err);
                }
            }
        }
        assert_eq!(block_count, 8);
        assert_eq!(block_bytes, 323);
    }

    #[test]
    fn test_car_v1_reader_find_block() {
        let mut reader = CarReader::new();
        let chunk_size = 50;
        let mut block_bytes = 0;
        let mut block_count = 0;

        // First, read the header
        loop {
            match reader.read_header() {
                Ok(()) => break,
                Err(CarReaderError::InsufficientData(read_from, _)) => {
                    let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                    if read_from >= end {
                        panic!("Test data exhausted before header could be read");
                    }
                    reader.receive_data(&CAR_V1[read_from..end], read_from);
                }
                Err(err) => {
                    panic!("Unexpected error while reading header: {:?}", err);
                }
            }
        }

        // Seek to the first section - Not needed here

        // Now, find the block with the given CID
        let target_cid = RawCid::from_hex(
            "01551220b6fbd675f98e2abd22d4ed29fdc83150fedc48597e92dd1a7a24381d44a27451",
        )
        .unwrap();
        loop {
            match reader.find_section(&target_cid) {
                Ok(section) => {
                    block_bytes += section.block().data().len();
                    block_count += 1;
                    assert_eq!(section.cid(), &target_cid);
                }
                Err(CarReaderError::InsufficientData(read_from, _)) => {
                    let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                    if read_from >= end {
                        // No more data to read
                        break;
                    }
                    reader.receive_data(&CAR_V1[read_from..end], read_from);
                }
                Err(err) => {
                    panic!("Unexpected error while reading section: {:?}", err);
                }
            }
        }

        assert_eq!(block_count, 1);
        assert_eq!(block_bytes, 4);
    }
}
