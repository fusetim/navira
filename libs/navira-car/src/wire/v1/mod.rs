use crate::wire::{
    v1::{
        data::{Section, SectionFormatError},
        header::CarHeader,
    },
    varint::UnsignedVarint,
};

pub mod data;
pub mod header;

/// CAR v1 reader
///
/// This struct provides functionality to read CAR v1 files, in a sans-io manner.
pub struct CarReader {
    /// Internal data buffer
    data: Vec<u8>,
    /// Internal data start position
    start: usize,
    /// Parsed header, if available
    header: Option<header::CarHeader>,
}

impl CarReader {
    /// Creates a new CarReader
    pub fn new() -> Self {
        CarReader {
            data: Vec::new(),
            start: 0,
            header: None,
        }
    }

    /// Fill the internal buffer with data
    ///
    /// # Arguments
    /// * `buf` - Buffer to fill from
    /// * `pos` - Offset position inside the CAR file which the buffer has been read from
    pub fn fill(&mut self, buf: &[u8], pos: usize) {
        // Internal behavior:
        // If pos == start + data.len(), append to the end
        // Otherwise, a "seek" has occurred, so reset the buffer
        if pos == self.start + self.data.len() {
            self.data.extend_from_slice(buf);
        } else {
            self.data.clear();
            self.data.extend_from_slice(buf);
            self.start = pos;
        }
    }

    /// Make progress in reading the CAR file, returning events as they are available
    ///
    /// # Returns
    /// * Vec<CarReaderEvent> - List of events emitted during progress
    ///
    /// Based on the events, the caller may need to provide more data via `fill()`.
    /// In particular when it received CarReaderEvent::InsufficientData(read_from, hint_length),
    /// you should try to read at least `hint_length` bytes starting from `read_from` offset.
    pub fn make_progress(&mut self) -> Vec<CarReaderEvent> {
        let mut events = Vec::new();

        // If header is not yet parsed, attempt to parse it
        if self.header.is_none() {
            // If start != 0, that means we are not at the beginning of the file
            // Seek at the beginning is required for CAR v1
            if self.start != 0 {
                events.push(CarReaderEvent::InsufficientData(0, Some(8)));
                return events;
            }

            // CARv1 header length is stored as an unsigned varint at the start of the file
            match UnsignedVarint::decode(&self.data) {
                Some((varint_len, varint_size)) => {
                    let header_len = varint_len.0 as usize;
                    let total_header_size = varint_size + header_len;

                    if self.data.len() < total_header_size {
                        // Not enough data to parse the full header
                        events.push(CarReaderEvent::InsufficientData(
                            self.start + self.data.len(),
                            Some(total_header_size - self.data.len()),
                        ));
                        return events;
                    }

                    // Parse the header
                    let header: CarHeader =
                        match ciborium::from_reader(&self.data[varint_size..total_header_size]) {
                            Ok(h) => h,
                            Err(err) => {
                                events.push(CarReaderEvent::ErrorOccurred(
                                    CarReaderError::InvalidHeader(err),
                                ));
                                return events;
                            }
                        };

                    // Store the parsed header
                    self.header = Some(header.clone());
                    events.push(CarReaderEvent::HeaderParsed(header));

                    // Remove the parsed header from the buffer
                    self.data.drain(0..total_header_size);
                    self.start += total_header_size;
                }
                None => {
                    // Not enough data to parse the varint (which is very strange, but possible)
                    events.push(CarReaderEvent::InsufficientData(
                        self.start + self.data.len(),
                        Some(8),
                    ));
                    return events;
                }
            }
        } else {
            // Header is parsed, proceed to parse sections
            match Section::try_read_bytes(&self.data) {
                Ok((section, section_size)) => {
                    // Successfully parsed a section
                    events.push(CarReaderEvent::SectionParsed(section));

                    // Remove the parsed section from the buffer
                    self.data.drain(0..section_size);
                    self.start += section_size;
                }
                Err(SectionFormatError::InsufficientData) => {
                    // Not enough data to parse a full section
                    events.push(CarReaderEvent::InsufficientData(
                        self.start + self.data.len(),
                        None,
                    ));
                    return events;
                }
                Err(err) => {
                    // Some other error occurred during section parsing
                    events.push(CarReaderEvent::ErrorOccurred(
                        CarReaderError::InvalidSectionFormat(err),
                    ));
                    return events;
                }
            }
        }

        events
    }
}

/// Errors related to CarReader operations
#[derive(thiserror::Error, Debug)]
pub enum CarReaderError {
    /// Invalid data format
    #[error("Invalid data format")]
    InvalidFormat(#[from] ciborium::de::Error<std::io::Error>),
    #[error("Invalid header format")]
    InvalidHeader(ciborium::de::Error<std::io::Error>),
    #[error("Invalid CAR version, expected 1, got {0}")]
    InvalidVersion(usize),
    #[error("Invalid section format")]
    InvalidSectionFormat(#[from] SectionFormatError),
}

/// Events emitted by the CarReader
#[derive(Debug)]
pub enum CarReaderEvent {
    HeaderParsed(header::CarHeader),
    SectionParsed(data::Section),
    ErrorOccurred(CarReaderError),
    InsufficientData(usize, Option<usize>),
}

#[cfg(test)]
mod tests {
    use super::{CarReader, CarReaderError, CarReaderEvent};
    use crate::wire::v1::data::Section;
    use crate::wire::v1::header::CarHeader;

    const CAR_V1: [u8; 715] = [
        // Offset 0x00000000 to 0x000002CA
        0x63, 0xA2, 0x65, 0x72, 0x6F, 0x6F, 0x74, 0x73, 0x82, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01,
        0x71, 0x12, 0x20, 0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F,
        0xA8, 0x30, 0x28, 0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D,
        0xBC, 0x20, 0x0F, 0xAB, 0x8B, 0xD8, 0x2A, 0x58, 0x25, 0x00, 0x01, 0x71, 0x12, 0x20, 0x69,
        0xEA, 0x07, 0x40, 0xF9, 0x80, 0x7A, 0x28, 0xF4, 0xD9, 0x32, 0xC6, 0x2E, 0x7C, 0x1C, 0x83,
        0xBE, 0x05, 0x5E, 0x55, 0x07, 0x2C, 0x90, 0x26, 0x6A, 0xB3, 0xE7, 0x9D, 0xF6, 0x3A, 0x36,
        0x5B, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x01, 0x5B, 0x01, 0x71, 0x12, 0x20,
        0xF8, 0x8B, 0xC8, 0x53, 0x80, 0x4C, 0xF2, 0x94, 0xFE, 0x41, 0x7E, 0x4F, 0xA8, 0x30, 0x28,
        0x68, 0x9F, 0xCD, 0xB1, 0xB1, 0x59, 0x2C, 0x51, 0x02, 0xE1, 0x47, 0x4D, 0xBC, 0x20, 0x0F,
        0xAB, 0x8B, 0xA2, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x2A, 0x58, 0x23, 0x00, 0x12, 0x20,
        0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 0xCB, 0x1F,
        0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2, 0x7F,
        0xD3, 0xDE, 0x64, 0x6E, 0x61, 0x6D, 0x65, 0x64, 0x62, 0x6C, 0x69, 0x70, 0x83, 0x01, 0x12,
        0x20, 0x02, 0xAC, 0xEC, 0xC5, 0xDE, 0x24, 0x38, 0xEA, 0x41, 0x26, 0xA3, 0x01, 0x0E, 0xCB,
        0x1F, 0x8A, 0x59, 0x9C, 0x8E, 0xFF, 0x22, 0xFF, 0xF1, 0xA1, 0xDC, 0xFF, 0xE9, 0x99, 0xB2,
        0x7F, 0xD3, 0xDE, 0x12, 0x2E, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0xB6, 0xFB, 0xD6, 0x75,
        0xF9, 0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 0xFD, 0xC8, 0x31, 0x50, 0xFE, 0xDC, 0x48,
        0x59, 0x7E, 0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 0x44, 0xA2, 0x74, 0x51, 0x12, 0x04,
        0x62, 0x65, 0x61, 0x72, 0x18, 0x04, 0x12, 0x2F, 0x0A, 0x22, 0x12, 0x20, 0x79, 0xA9, 0x82,
        0xDE, 0x3C, 0x99, 0x07, 0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 0x1D, 0x0F, 0xB1, 0xED, 0x8F,
        0x45, 0xF8, 0xEF, 0x02, 0x87, 0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 0xBD, 0x53, 0x0A, 0x12,
        0x06, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x18, 0x95, 0x01, 0x28, 0x01, 0x55, 0x12, 0x20,
        0xB6, 0xFB, 0xD6, 0x75, 0xF9, 0x8E, 0x2A, 0xBD, 0x22, 0xD4, 0xED, 0x29, 0xFD, 0xC8, 0x31,
        0x50, 0xFE, 0xDC, 0x48, 0x59, 0x7E, 0x92, 0xDD, 0x1A, 0x7A, 0x24, 0x38, 0x1D, 0x44, 0xA2,
        0x74, 0x51, 0x63, 0x63, 0x63, 0x63, 0x80, 0x01, 0x12, 0x20, 0x79, 0xA9, 0x82, 0xDE, 0x3C,
        0x99, 0x07, 0x95, 0x3D, 0x4D, 0x32, 0x3C, 0xEE, 0x1D, 0x0F, 0xB1, 0xED, 0x8F, 0x45, 0xF8,
        0xEF, 0x02, 0x87, 0x0C, 0x0C, 0xB9, 0xE0, 0x92, 0x46, 0xBD, 0x53, 0x0A, 0x12, 0x2D, 0x0A,
        0x24, 0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 0x86, 0x74, 0xB4, 0x01, 0xB4,
        0x2F, 0x35, 0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 0xBF, 0xFE, 0x65, 0x8D,
        0xA1, 0x57, 0x7E, 0x3E, 0x64, 0x68, 0x77, 0x12, 0x03, 0x64, 0x6F, 0x67, 0x18, 0x04, 0x12,
        0x2D, 0x0A, 0x22, 0x12, 0x20, 0xE7, 0xDC, 0x48, 0x6E, 0x97, 0xE6, 0xEB, 0xE5, 0xCD, 0xAB,
        0xAB, 0x3E, 0x39, 0x2B, 0xDA, 0xD1, 0x28, 0xB6, 0xE0, 0x9A, 0xCC, 0x94, 0xBB, 0x4E, 0x2A,
        0xA2, 0xAF, 0x7B, 0x98, 0x6D, 0x24, 0xD0, 0x12, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0x18,
        0x33, 0x28, 0x01, 0x55, 0x12, 0x20, 0x81, 0xCC, 0x5B, 0x17, 0x01, 0x86, 0x74, 0xB4, 0x01,
        0xB4, 0x2F, 0x35, 0xBA, 0x07, 0xBB, 0x79, 0xE2, 0x11, 0x23, 0x9C, 0x23, 0xBF, 0xFE, 0x65,
        0x8D, 0xA1, 0x57, 0x7E, 0x3E, 0x64, 0x68, 0x77, 0x62, 0x62, 0x62, 0x62, 0x51, 0x12, 0x20,
        0xE7, 0xDC, 0x48, 0x6E, 0x97, 0xE6, 0xEB, 0xE5, 0xCD, 0xAB, 0xAB, 0x3E, 0x39, 0x2B, 0xDA,
        0xD1, 0x28, 0xB6, 0xE0, 0x9A, 0xCC, 0x94, 0xBB, 0x4E, 0x2A, 0xA2, 0xAF, 0x7B, 0x98, 0x6D,
        0x24, 0xD0, 0x12, 0x2D, 0x0A, 0x24, 0x01, 0x55, 0x12, 0x20, 0x61, 0xBE, 0x55, 0xA8, 0xE2,
        0xF6, 0xB4, 0xE1, 0x72, 0x33, 0x8B, 0xDD, 0xF1, 0x84, 0xD6, 0xDB, 0xEE, 0x29, 0xC9, 0x88,
        0x53, 0xE0, 0xA0, 0x48, 0x5E, 0xCE, 0xE7, 0xF2, 0x7B, 0x9A, 0xF0, 0xB4, 0x12, 0x03, 0x63,
        0x61, 0x74, 0x18, 0x04, 0x28, 0x01, 0x55, 0x12, 0x20, 0x61, 0xBE, 0x55, 0xA8, 0xE2, 0xF6,
        0xB4, 0xE1, 0x72, 0x33, 0x8B, 0xDD, 0xF1, 0x84, 0xD6, 0xDB, 0xEE, 0x29, 0xC9, 0x88, 0x53,
        0xE0, 0xA0, 0x48, 0x5E, 0xCE, 0xE7, 0xF2, 0x7B, 0x9A, 0xF0, 0xB4, 0x61, 0x61, 0x61, 0x61,
        0x36, 0x01, 0x71, 0x12, 0x20, 0x69, 0xEA, 0x07, 0x40, 0xF9, 0x80, 0x7A, 0x28, 0xF4, 0xD9,
        0x32, 0xC6, 0x2E, 0x7C, 0x1C, 0x83, 0xBE, 0x05, 0x5E, 0x55, 0x07, 0x2C, 0x90, 0x26, 0x6A,
        0xB3, 0xE7, 0x9D, 0xF6, 0x3A, 0x36, 0x5B, 0xA2, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xF6, 0x64,
        0x6E, 0x61, 0x6D, 0x65, 0x65, 0x6C, 0x69, 0x6D, 0x62, 0x6F,
    ];

    #[test]
    fn test_car_v1_reader() {
        let mut reader = CarReader::new();
        let chunk_size = 50;
        let mut block_cids = Vec::new();
        let mut cum_block_size = 0;

        'read_loop: loop {
            let events = reader.make_progress();
            if events.is_empty() {
                break 'read_loop;
            }
            for event in events {
                match event {
                    CarReaderEvent::HeaderParsed(header) => {
                        assert_eq!(header.roots().len(), 2);
                    }
                    CarReaderEvent::SectionParsed(section) => {
                        println!(
                            "Found block {}, sectlen: {}, datalen: {}",
                            section.cid(),
                            section.length(),
                            section.block().data().len()
                        );
                        block_cids.push(section.cid().clone());
                        cum_block_size += section.block().data().len();
                    }
                    CarReaderEvent::ErrorOccurred(err) => {
                        panic!("Error occurred: {:?}", err);
                    }
                    CarReaderEvent::InsufficientData(read_from, _) => {
                        let end = std::cmp::min(read_from + chunk_size, CAR_V1.len());
                        if end == read_from {
                            break 'read_loop; // No more data to read
                        }
                        reader.fill(&CAR_V1[read_from..end], read_from);
                    }
                    _ => {}
                }
            }
        }
        dbg!(&block_cids);
        assert_eq!(block_cids.len(), 8);
        assert_eq!(cum_block_size, 323);
    }
}
